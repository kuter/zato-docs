.. highlight:: python
   :linenothreshold: 1

Tutorial - part 1/2
===================

Introduction
------------

This tutorial will guide you through a process of creating a simple, yet realistic, **Zato** and
**Python-based enterprise integration platform** based on **SOA services** and **multi-protocol publish/subscribe topics**.

The environment will integrate a few systems in a **scalable** and **secure** manner. You will learn how to install,
configure and make use of all the components that Zato comprises - **servers**, **web-admin**, **scheduler**
and **load-balancer**.

Zato is an
:doc:`enterprise integration platform <../intro/esb-soa>`
and backend application server
that can be used in a range of domains, such as **banking**,
**healthcare**, **public administration**, **mobile**, **IoT** and many more but, to set the scope of this document,
**telecommunication** was chosen.

Thus, for illustration purposes, the tutorial will implement services related to recharging of
pre-papid SIM cards at a telecommunication operator.

But first, what is a service? What is a topic?

To paraphrase the :doc:`programming guide <../progguide/overview>`, a service is a piece of functionality that does
something useful and interesting to any party that would like to use it. It is like a function or a method but
running on a massively higher level - instead of exposing functions to other parts of code in a single application,
a service is exposed as an API to other systems.

Such an atomic and reusable building block as a service can be used to create any online
:doc:`middleware and backend <../intro/overview-high-level>` :doc:`application <../intro/overview-tech>` for any purpose -
Zato supports **dozens of protocols, data formats, techniques and integration patterns**.

Topics participate in integration processes on a slightly different level - they let one integrate applications or components
that are not necessarily available at the same time. When messages are published to a topic, all subscribers to that topic
receive them independently and if some subscribers are not available, Zato will retain the messages safely in order to deliver
them at a later time, hence ensuring that a message will be transmitted even if a particular subscriber is not
available at any given time.

Just like services, topics are of multi-protocol nature, and they let one integrate asynchronously applications
that perhaps do not use the same technologies.

Services and topics cooperate in both directions, services may use topics and topics may use services in integration
projects.

Services and topics are a major part of Zato but an associated one, though partly independent, is
:doc:`Single Sign-On (SSO) <../sso/index>`,
which lets one provide authentication and authorization to external systems via REST and Python.

Most of the functionality in Zato revolves around servers but there is also
:doc:`CLI <../admin/cli/index>`,
API
and a
:doc:`web-admin <../web-admin/intro>`
console for developers and admins to use.

What will the tutorial achieve, exactly?
----------------------------------------

From the business perspective, we will implement a process as follows:

* Users request that their pre-paid SIM card be recharged

* Zato will accept requests

* Zato will ask the scoring system if a particular user request should be allowed
  and if so, should the user perhaps receive an extra bonus

* If the request is allowed, the user receives a success message and two background notifications are sent:

  * To a system that will actually recharge the card (Intelligent Network, IN)
  * To an SMS Center (SMSC) to let the user know that the operation succeeded

* If users are not allowed, they will receive an error message

* If allowed and the amount for the card to be recharged with should exceed a particular limit,
  a monitoring system will get an asynchronous publish/subscribe notification and an email
  will be sent to operators of the system

The applications involved will use different protocols or data formats, such as REST, JSON, SOAP, XML,
publish/subscribe and SMTP (for email).

.. image:: /gfx/tutorial/process.png

What we will implement will be a real and fully working process, one that could be applicable to an actual
telecommunication operator though, depending on an operator, the process could be much more complex,
there could be more systems involved or different protocols could be employed.

Yet, this tutorial is already representative of the way actual business processes can be implemented in Zato -
any extensions to what we are going to implement would follow the same logic and techniques.

Note that in the process we do not specify exactly what kind of a client application users have access to,
be it a mobile app, SMS gateway or anything else - we will get back to this subject later.

.. _tutorial-01-install-zato:

Installing Zato
---------------

Zato can be
:doc:`installed <../admin/guide/install/index>`
under Ubuntu, RHEL/CentOS, Debian or Docker, including Kubernetes and Swarm. For Windows and Mac, use Vagrant,
Docker or install a VM with a Linux distribution of choice.

First, though, we need to choose which Python version we would like to use. Zato supports both Python 2.7 and 3.x.
For new installations, it may be a good idea to choose Python 3 but if you prefer to use Python 2.7
then this is perfectly fine - you can even install a Python 2.7 environment and then migrate
it to Python 3 or the other way around.

If you know only Python 2.7 then be assured that with Zato all of your knowledge will transfer effortlessly
to Python 3 because Zato operates on such a high-level that any individual differences between the Python versions
are irrelevant.

Everything from this tutorial will work in the same way regardless of which Python version you choose so you can simply
pick the one that you are most familiar with.

Note also that there are no plans to drop Python 2.7 compatibility in the foreseeable future.

If you like Docker then the simplest way is to install Zato is to make use of the
:doc:`quickstart image <../admin/guide/install/py3/docker>`
which auto-configures the whole of the environment - its sets up a new Zato cluster along with its dependencies,
components and users.

Otherwise, if not using Docker, follow the two-step instructions below.

1. As a prerequisite - you need access to `Redis <http://redis.io>`_ - this is an external component
   which is not shipped with Zato and needs to be installed separately. So first, install Redis and start it.

2. Visit
   :doc:`this page <../admin/guide/install/index>`, install Zato under the preferred operating system and Python version,
   and then return to this tutorial.

Creating a quickstart cluster
-----------------------------

Is Zato installed already? Great, now, if you are not using Docker, let us create a quickstart cluster,
which is the kind of cluster
created by running the
:doc:`CLI command <../../admin/cli/index>`,
appropriately called
:doc:`zato quickstart create <../../admin/cli/quickstart-create>`.

A quickstart cluster is one that has all of its components auto-configured and ready to use in ten seconds. It is a fully
working environment that can be used for production, test and development purposes alike so it is a good idea to have
one for this tutorial.

Remember, the steps below are needed only if you are not using a quickstart Docker image, e.g. if you installed Zato
in its own Linux VM.

You need to prepare:

* As user zato, an empty directory ($path), such as ~/env/qs-1
* Host, port and a password for connecting to Redis ($kvdb_host, $kvdb_port and $kvdb_password)

Note that user user zato created during Zato installation does not have any default password. It means that you need either to
execute 'sudo su - zato' or 'su - zato' to switch to that user or change the zato user's password first as root or another
account with elevated privileges.

Now run the following command as user zato, substituting placeholders with the information
you have prepared. You will be asked for passwords and they will not be echoed.

In the command below, observe that the Redis password can be empty - indeed, if you have just installed Redis without
configuring anything, it must be empty because by default Redis does not require it.

::

  $ zato quickstart create $path sqlite $kvdb_host $kvdb_port \
    --kvdb_password $kvdb_password --verbose

For instance:

.. code-block:: text
  :emphasize-lines: 14

  $ zato quickstart create ~/env/qs-1 sqlite localhost 6379 \
    --kvdb_password '' --verbose
  [1/9] Certificate authority created
  [2/9] ODB schema created
  [3/9] ODB initial data created
  [4/9] server1 created
  [5/9] server2 created
  [6/9] Load-balancer created
  Superuser created successfully.
  [7/9] Web admin created
  [8/9] Scheduler created
  [9/9] Management scripts created
  Quickstart cluster quickstart-670931 created
  Web admin user:[admin], password:[Ok4xSv14tDVAAywgnceNdb791OwPW0SK]
  Start the cluster by issuing the /opt/zato/env/qs-1/zato-qs-start.sh command
  Visit https://zato.io/support for more information and support options
  $

Note the highlighted line - these are credentials you will need to log into a
:doc:`web admin's instance <../web-admin/intro>`
just created under http://localhost:8183.

The password cannot be retrieved in clear text if you do not note it down but you can always reset it
using the
:doc:`zato update password <../../admin/cli/update-password>`
command.

Understanding quickstart clusters
----------------------------------

What was created by invoking zato quickstart create:

* A development TLS Certificate Authority
* Two servers
* A high-availability load-balancer in front of the two
* A web-admin panel instance and an admin user
* A scheduler
* Operational data in SQLite and Redis
* Scripts to (re-)start the environment and stop it

The whole of it uses randomly generated crypto material and is automatically configured so that
all the parts are aware of each other, e.g. the load balancer knows what servers to route the traffic to,
the web admin understands where all the components to manage are and so on.

In short, the command has just created a full environment.

Note that a quickstart environment is a complete one. If you were to create and configure all of the individual
components from scratch the result would be the same.

Important TCP ports that will be used are:

================================== =======================================================================
Port                               Notes
================================== =======================================================================
`11223 <http://localhost:11223>`_  Load-balancer's HTTP port
                                   (this is what external applications use to invoke services you develop)
`17010 <http://localhost:17010>`_  server1's HTTP port
`17011 <http://localhost:17011>`_  server2's HTTP port
`8183 <http://localhost:8183>`_    Web admin's HTTP port (this is where you point your browser to and log
                                   in as an admin user)
================================== =======================================================================

.. image:: /gfx/tutorial/quickstart-ports.png

Keep in mind that the load-balancer and servers can all run on different hosts, but to stay focused
on basic things first, it is a quickstart cluster which installs everything on localhost that this tutorial uses.

And although this is a tutorial only, this can be a good approach to easily create any serious Zato environment later on.
Just create a quickstart cluster, rename it to 'dev1' or similarly and start
:doc:`adding and configuring <../../admin/guide/install-config/overview>`
as many servers as you need.

Invoking services with curl
---------------------------

.. note ::

  At this point, **you need to make sure that Redis is up, running and it lets Zato connect**,
  i.e. the Redis credentials you provided earlier, if any, are valid.

  You can check it by running these commands:

  ::

    $ zato check-config $path/server1
    SQL ODB connection OK
    Redis connection OK
    $

  ::

    $ zato check-config $path/server2
    SQL ODB connection OK
    Redis connection OK
    $

  If there is no output as shown above, the ./zato-qs-start.sh command below will not succeed. Again, please make sure
  that Redis will allow Zato to establish connections.

First off, let us start the environment:

::

  $ ./zato-qs-start.sh
  Starting Zato cluster quickstart-670931
  Checking configuration
  [1/8] Redis connection OK
  [2/8] SQL ODB connection OK
  [3/8] Checking TCP ports availability
  [4/8] Load-balancer started
  [5/8] server1 started
  [6/8] server2 started
  [7/8] Scheduler started
  [8/8] Web admin started
  Zato cluster quickstart-670931 started
  Visit https://zato.io/support for more information and support options
  $

Zato comes with several helper tools and one of them is the zato.ping service which is automatically
mounted on /zato/ping so it can be invoked through the load-balancer using curl:

::

  $ curl localhost:11223/zato/ping ; echo
  {
    "zato_env": {"result": "ZATO_OK", "cid": "c0a72d17e601ccdb18936d2e", "details": ""},
    "zato_ping_response": {"pong": "zato"}
  }
  $

* The response produced by zato.ping is a JSON document.
* We can find that there were no errors encountered (ZATO_OK)
* The :ref:`correlation ID <progguide-write-service-cid>` (cid) serves as an
  identifier which can be used to reconcile information regarding the fate of a service's
  invocation across multiple systems

If the output is as above then everything is good - the cluster is up and running and you can create your first
service now.

Hot-deploying your first service
--------------------------------

Open your favorite programming editor and save the following code as api.py

::

  from zato.server.service import Service

  class RechargeCard(Service):
      def handle(self):
          self.log_input()

* Each
  :doc:`service <../progguide/service-dev>`
  always subclasses zato.server.service.Service

* :ref:`handle(self) <progguide-write-service-handle>`
  is the only method that a service must implement,
  this is where the actual action takes place, this is the heart of a service

* :ref:`log_input <progguide-write-service-log_input>`
  is one of the helper methods a service has access to. This particlar one one dumps all the input data to server logs.

Having saved the code on disk, now we can hot-deploy it.

There are :doc:`several ways <../../admin/guide/installing-services>` to make code available to Zato
and hot-deployment is one of them.

Either through command line or using web-admin, you can push services to one of the servers in a cluster and it will be
picked up automatically by all the nodes without any restarts. This includes updates to services that already exist.

To hot-deploy a service from command line you need to copy the Python module it is in to a pick-up directory.

The tutorial assumes that you use a standalone VM but note that if you are under Docker quickstart you can
either copy the file to to container or map /opt/hot-deploy in the container to a directory of choice on your host -
check :ref:`Docker quickstart installation <install-py3-docker-quickstart>` docs for details.

There will be two directories to hot-deploy services through, $path/**server1**/pickup/incoming/services and
$path/**server2**/pickup/incoming/services, it does not matter which one you choose as the other
server will instantly synchronize its state with the one that will have received the service.

So, choosing $path/server1/pickup/incoming/services, copy the module:

::

  $ cp api.py $path/server1/pickup/incoming/services

Now, in each server log file (server.log), a confirmation message will appear:

::

  INFO - zato.hot-deploy.create:33 - Uploaded package id:`1`, payload_name:`api.py`

Our service is there but we can not reach it from the client application yet because
it is not exposed through any
:doc:`channel <../../progguide/channels>` - a single service can be used over
many independent channels, each using different security configuration, transport
protocols, data format and more.

You need to explicitly tell Zato how to make a given service available to all
and each of external systems interested in invoking it. You do it in
web-admin so now, open http://localhost:8183/ in your web browser.

Log in using the credentials created along with the quickstart cluster
or :doc:`update <../../admin/cli/update-password>` the admin user's
password if you do not have access to them anymore.

.. image:: /gfx/tutorial/web-admin-login.png

From the main menu pick *Services*, type *api* in the search box and click *Show services*.

.. image:: /gfx/tutorial/web-admin-search.png
   :width: 95%

This confirms that the service indeed exists on the cluster even though it is
still not possible to access it from the outside.

A question may arise, how come the service is called api.get-client-details? It is because Zato uncamelifies
strings such as MyName or PrepareCustomerDocuments into my-name or prepare-customer-documents to make them more Pythonic.
Naturally, this can be :ref:`overridden <progguide-write-service-get_name>`.

Exposing a service over HTTP and invoking it
--------------------------------------------

Since the service is deployed we can make it possible for others to invoke it now.

Still in web-admin, navigate to Connections -> Channels -> REST

.. image:: /gfx/tutorial/web-admin-channels.png
  :width: 95%

.. and create a new channel ..

.. image:: /gfx/tutorial/web-admin-channels-new.png

Note that in order to emphasize the point that a service's name is decoupled
from names of any channels that may be using it or from an HTTP path it is mounted
under, those values are all different in the tutorial.

.. image:: /gfx/tutorial/web-admin-channels-new-success.png
   :width: 95%

And that is it. The channel has been created, all servers have been notified of
its having been formed so they automatically hot-updated their HTTP configuration and we can
now use curl again to invoke our newly created REST endpoint.

::

  $ curl localhost:11223/api/recharge-card
  $

This does not produce any output because the service returns none, it is only
logging its input data to server logs so this is where we need to look for
a palpable proof that a service was indeed invoked.

Note that the request went through a load-balancer and because we use local
files instead of logging to syslog, we can not be sure which server's logs to check
hence you need to grep in both of them and look for an entry similar to the one below.

Its contents is the full data and metadata pertaining to the incoming request.

::

  INFO - api.recharge-card:0 - {'request.payload': b'', 'channel': 'http-soap',
    'cid': 'efbb3ddd4a2716396546c481', 'data_format': '',
    'environ': {}, 'impl_name': 'api.RechargeCard',
    'invocation_time': datetime.datetime(2019, 11, 2, 16, 0, 56, 299),
    'job_type': None, 'name': 'api.recharge-card', 'slow_threshold': None,
    'usage': 1, 'wsgi_environ':
    {wsgi.version': (1, 0), 'wsgi.multithread': True, 'wsgi.multiprocess': False,
    'wsgi.file_wrapper': <class 'zato.server.ext.zunicorn.http.wsgi.FileWrapper'>,
    'wsgi.input': <zato.server.ext.zunicorn.http.body.Body object at 0x7f9bea6af710>,
    'gunicorn.socket': <gevent._socket3.socket object, fd=71,
    family=2, type=2049, proto=0>, 'REQUEST_METHOD': 'GET', 'QUERY_STRING': '',
    'RAW_URI': '/api/recharge-card',
    'SERVER_PROTOCOL': 'HTTP/1.1', 'HTTP_HOST': 'localhost:11223',
    'HTTP_USER_AGENT': 'curl/7.58.0', 'HTTP_ACCEPT': '*/*',
    'HTTP_X_FORWARDED_FOR': '127.0.0.1',
    'HTTP_CONNECTION': 'close', 'wsgi.url_scheme': 'http', 'REMOTE_ADDR': '127.0.0.1',
    'REMOTE_PORT': '41408', 'SERVER_NAME': '0.0.0.0', 'SERVER_PORT': '17010',
    'PATH_INFO': '/api/recharge-card', 'SCRIPT_NAME': '',
    'zato.local_tz': <DstTzInfo 'Europe/Prague' LMT+0:58:00 STD>,
    'zato.request_timestamp_utc': datetime.datetime(2019, 11, 2, 16, 0, 55, 999675),
    'zato.request_timestamp': datetime.datetime(2019, 11, 2, 17, 0, 55, 999675,
    tzinfo=<DstTzInfo 'Europe/Prague' CET+1:00:00 STD>),
    'zato.http.response.headers': {'X-Zato-CID': 'efbb3ddd4a2716396546c481'},
    'zato.http.remote_addr': '127.0.0.1', 'zato.channel_item':
    {'connection': 'channel', 'content_type': None, 'data_format': '',
    'host': None, 'id': 689,
    'has_rbac': False, 'impl_name': 'api.RechargeCard', 'is_active': True,
    'is_internal': False,
    'merge_url_params_req': True, 'method': '', 'name': 'Recharge Card',
    'params_pri': 'channel-params-over-msg', 'ping_method': None, 'pool_size': None,
    'service_id': 756, 'service_name': 'api.recharge-card', 'soap_action': '',
    'soap_version': None,
    'transport': 'plain_http', 'url_params_pri': 'qs-over-path',
    'url_path': '/api/recharge-card',
    'sec_use_rbac': False, 'cache_type': None, 'cache_id': '',
    'cache_name': None, 'cache_expiry': 0,
    'content_encoding': '',
    'match_slash': True, 'service_whitelist': '',
    'service_impl_name': 'api.RechargeCard',
    'is_rate_limit_active': False, 'rate_limit_def': '',
    'rate_limit_type': 'APPROXIMATE', 'rate_limit_check_parent_def': False},
    'zato.http.raw_request': b'',
    'zato.oauth.post_data': {}, 'zato.http.GET': {}, 'zato.http.POST': {},
    'zato.http.path_params': {}}

And that concludes the first part! You have created a multi-component cluster and a service. The service was hot-deployed
and then invoked successfully.

The :doc:`next part <./02>` will focus much
more on the business functionality now that the general framework to work within has
been laid down.

:doc:`Continue on to part 2/3 <./02>`
